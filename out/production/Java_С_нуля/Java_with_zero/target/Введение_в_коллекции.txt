-----------Введение в коллекции----------
1. Тип данных Object - всему голова.
Объект любого типа данных можно УПАКОВАТЬ в объект типа Object, а при необходимости потом распаковать и привести
к необходимому типу
Object o = 1.2 // присвоено значение типа double объекту типа object
любой класс наследуется от класса Object и к нему применимы все методы и поля класса Object
        Object number = 1.25;
        Object string = "Валентин";
        System.out.println(number); // 1.25
        System.out.println(string); // Валентин
        People man = new People(35,"Stas");
        System.out.println(man); // People@378bf509 - уникальный hash код для объекта, по умолчанию выполняется
                                 // метод .toString(), который наследуется всеми классами от класса Object
        System.out.println(man.toString()); // People@378bf509 - результат такой же
для того, чтобы для объектов класса People метод toString() выдавал не hash код, как это определено по умолчанию в
классе Object - необходимо переопределить этот метод внутри класса People c желаемым вариантом вывода информации в консоль
// переопределили внутри класса People классический унаследованный от Object метод toString c целью вывода на экран не hash кода а нужной
    //информации
    public String toString() {
        return name+","+age;
        }
        System.out.println(man); // Stas,35  - результат вывода в консоль с переопределенным методом toString()
    -----ближе к коллекциям-----
    для того, чтобы можно было динамически изменять размер итерируемого объекта, допустим из массива в 5 элементов
    сделать массив 6 элементов необходимо проводить определенные операции с оперативной памятью (выделять ссылки на новые объекты
    копировать в них старые объекты, затирать промежуточные ссылки и объекты, при этом, чтобы уйти от необходимости добавлять
    по одному объекту разработчиками Java сразу было придумано динамически расширять итерируемый объект, допустим при добавлении
    6 элемента к массиву из 5 элементов, сразу будет резервироваться 10 элементов, 21 к 20-ти элементному - сразу 40,
    все это реализовано с помощью классов и методов коллекций
1. За основу коллекций берем класс Collection, далее его наследуют классы List, Set, Queue, немного особняком стоит класс Map
2. _-----удобный массив-----ArrayList
ArrayList arrayList = new ArrayList(); // инициализация объекта arrayList класса ArrayList
Все методы, которые применимы к ArrayList также применимы и для LinkedList, Vector, Stack
ArrayList - пронумерованный список элементов
Для того, чтобы не создавать сырой объект класса Object (а сейчас тип данных, который будет храниться в arrayList не указан
указываем обобщение <Integer> после указания типа объекта
ArrayList<Integer> arrayList = new ArrayList<Integer>();
        arrayList.add(2808); // добавление целочисленного элемента в объект типа ArrayList
        for (Object element: arrayList) { // вывод на экран через цикл foreach
            System.out.println(element);
            }
при этом нельзя будет добавить элемент не типа Integer например
arrayList.add("1234"); // java: incompatible types: java.lang.String cannot be converted to java.lang.Integer
ArrayList<Integer> arrayList = new ArrayList<Integer>(10); //создаст ссылку на лист с 10 элементами, который потом может быть расширен
ArrayList<Integer> arrayList = new ArrayList<Integer>(list1); //создаст ссылку на копию объекта list1
3. Получение итератора на базе коллекции.
